# -*- coding: utf-8 -*-
"""
Calculate the in-plane phonon dispersion curves on the Gamma - M - K - Gamma path
"""
from itertools import chain
from pathlib import Path

import npstreams as ns
import numpy as np
from crystals import Atom, Crystal, Element
from crystals.affine import change_of_basis
from crystals.parsers import PWSCFParser
from scipy.interpolate import griddata
from tqdm import tqdm

from mkoneph import (
    prepare_modes,
    render,
    IN_PLANE_MODES,
)

INPUT = Path(__file__).parent.parent / "data" / "graphite"
OUTPUT = INPUT / "static-dispersion"
OUTPUT.mkdir(exist_ok=True)


def mkpath(points, nsteps):
    """Create a path in reciprocal space

    Parameters
    ----------
    points : iterable of ndarrays, shape (3,)
        The path will be generated by connecting adjacent points.
    nsteps : int
        Number of steps to generate between each point.

    Returns
    -------
    path : ndarray, shape (N, 3)
        Table of points along the path in reciprocal space. Each row is a different point.
    vertices : iterable of ndarrays, shape (3,)
        `points` scaled to fit reciprocal space.
    """
    cryst = Crystal.from_pwscf(INPUT / "output.out")
    pairs = [(points[i], points[i + 1]) for i in range(len(points) - 1)]
    frac_path = list(
        chain.from_iterable(
            [ns.multilinspace(p0, p1, num=nsteps, endpoint=False) for p0, p1 in pairs]
        )
    )
    frac_path = np.array(frac_path)

    # Cast path to q-points (not fractional)
    from_frac = change_of_basis(np.array(cryst.reciprocal_vectors), np.eye(3))
    path = np.transpose(from_frac @ frac_path.T)
    vertices = [from_frac @ point for point in points]
    return path, vertices


def dispersion(mode_str, path, reflections):
    """
    Calculate a dispersion curve weighted by the one-phonon structure factor
    """
    modes = prepare_modes(reflections=tuple(reflections))
    mode = modes[mode_str]

    # Interpolate values of the dispersion over the path
    pathx, pathy, _ = np.hsplit(path, 3)
    pathx, pathy = np.squeeze(pathx), np.squeeze(pathy)

    freq = np.squeeze(
        griddata(
            points=mode.q_points[:, 0:2],
            values=mode.frequencies,
            xi=(pathx, pathy),
            method="linear",
            fill_value=0.0,
        )
    )

    return freq


# BZ (010)
_, e2, _ = np.eye(3)
gamma = np.array((0, 0, 0)) + e2
mpoint = np.array((0, 1 / 2, 0)) + e2
kpoint = np.array((1 / 3, 1 / 3, 0)) + e2

nsteps = 1000
q_path, vertices = mkpath(points=[gamma, mpoint, kpoint, gamma], nsteps=nsteps)

reflections = tuple([(0, 0, 0), (0, 1, 0), (-1, 1, 0)])

if __name__ == "__main__":
    for mode_str in tqdm(IN_PLANE_MODES):
        f = dispersion(mode_str, path=q_path, reflections=reflections)
        np.save(OUTPUT / f"{mode_str}.npy", f)
